export const adjectives100 = ["active", "adaptable", "adventurous", "affectionate", "alert", "artistic", "assertive", "boundless", "brave", "bright","broad-minded", "calm", "capable", "careful", "caring", "cheerful", "clever", "comfortable", "communicative", "compassionate", "conscientious", "considerate", "courageous", "creative", "curious", "decisive", "determined", "diligent", "dynamic", "eager", "energetic", "entertaining", "enthusiastic", "exuberant", "expressive", "fabulous", "fair-minded", "fantastic", "fearless", "flexible-thinker", "frank", "friendly", "funny", "generous", "gentle", "gregarious", "happy", "hard-working", "helpful", "hilarious", "honest", "imaginative", "independent", "intellectual", "intelligent", "intuitive", "inventive", "joyous", "kind", "kind-hearted", "knowledgable", "level-headed", "lively", "loving", "loyal", "mature", "modest", "optimistic", "outgoing", "passionate", "patient", "persistent", "philosophical", "polite", "practical", "pro-active", "productive", "quick-witted", "quiet", "rational", "receptive", "reflective", "reliable", "resourceful", "responsible", "selective", "self-confident", "sensible", "sensitive", "skillful", "straightforward", "successful", "thoughtful", "trustworthy", "understanding", "versatile", "vivacious", "warm-hearted", "witty", "wonderful"]
export const colors50 = ["aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "bluegreen", "bluepurple", "cornsilk", "floralwhite", "gainsboro", "ghostwhite", "honeydew", "ivory", "khaki", "lavender", "lavenderblush", "lemonchiffon", "lightblue", "lightcyan", "lightgoldenrodyellow", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightskyblue", "lightsteelblue", "lightyellow", "linen", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "palegoldenrod", "palegreen", "paleturquoise", "papayawhip", "peachpuff", "pink", "plum", "powderblue", "seashell", "silver", "snow", "thistle", "wheat", "white", "whitesmoke"]
export const items110 = ["gorilla", "poodle", "wolf", "fox", "raccoon", "cat", "horse", "unicorn", "zebra", "deer", "ox", "cow", "boar", "ram", "ewe", "goat", "camel", "llama", "giraffe", "elephant", "rhinoceros", "hippopotamus", "mouse", "rat", "hamster", "rabbit", "chipmunk", "hedgehog", "bat", "bear", "koala", "panda", "kangaroo", "badger", "turkey", "chicken", "rooster", "bird", "penguin", "dove", "eagle", "duck", "swan", "owl", "peacock", "parrot", "frog", "crocodile", "turtle", "lizard", "sauropod", "t-Rex", "whale", "dolphin", "fish", "blowfish", "octopus", "butterfly", "ant", "honeybee", "cricket", "avocado", "eggplant", "potato", "carrot", "cucumber", "broccoli", "mushroom", "chestnut", "bread", "croissant", "baguette", "pretzel", "bagel", "pancakes", "bacon", "pizza", "sandwich", "taco", "burrito", "cooking", "popcorn", "salt", "guitar", "trumpet", "violin", "drum", "grapes", "melon", "watermelon", "tangerine", "lemon", "pineapple", "apple", "pear", "peach", "cherries", "strawberry", "kiwi", "mango", "Seedling", "tree", "cactus", "tulip", "rose", "hibiscus", "sunflower", "blossom", "herb", "clover"]
export const itemToEmoji = { "gorilla": "🦍", "poodle": "🐩", "wolf": "🐺", "fox": "🦊", "raccoon": "🦝", "cat": "🐈", "horse": "🐎", "unicorn": "🦄", "zebra": "🦓", "deer": "🦌", "ox": "🐂", "cow": "🐄", "boar": "🐗", "ram": "🐏", "ewe": "🐑", "goat": "🐐", "camel": "🐪", "llama": "🦙", "giraffe": "🦒", "elephant": "🐘", "rhinoceros": "🦏", "hippopotamus": "🦛", "mouse": "🐁", "rat": "🐀", "hamster": "🐹", "rabbit": "🐇", "chipmunk": "🐿", "hedgehog": "🦔", "bat": "🦇", "bear": "🐻", "koala": "🐨", "panda": "🐼", "kangaroo": "🦘", "badger": "🦡", "turkey": "🦃", "chicken": "🐔", "rooster": "🐓", "bird": "🐦", "penguin": "🐧", "dove": "🕊", "eagle": "🦅", "duck": "🦆", "swan": "🦢", "owl": "🦉", "peacock": "🦚", "parrot": "🦜", "frog": "🐸", "crocodile": "🐊", "turtle": "🐢", "lizard": "🦎", "sauropod": "🦕", "t-Rex": "🦖", "whale": "🐋", "dolphin": "🐬", "fish": "🐟", "blowfish": "🐡", "octopus": "🐙", "butterfly": "🦋", "ant": "🐜", "honeybee": "🐝", "cricket": "🦗", "avocado": "🥑", "eggplant": "🍆", "potato": "🥔", "carrot": "🥕", "cucumber": "🥒", "broccoli": "🥦", "mushroom": "🍄", "chestnut": "🌰", "bread": "🍞", "croissant": "🥐", "baguette": "🥖", "pretzel": "🥨", "bagel": "🥯", "pancakes": "🥞", "bacon": "🥓", "pizza": "🍕", "sandwich": "🥪", "taco": "🌮", "burrito": "🌯", "cooking": "🍳", "popcorn": "🍿", "salt": "🧂", "guitar": "🎸", "trumpet": "🎺", "violin": "🎻", "drum": "🥁", "grapes": "🍇", "melon": "🍈", "watermelon": "🍉", "tangerine": "🍊", "lemon": "🍋", "pineapple": "🍍", "apple": "🍎", "pear": "🍐", "peach": "🍑", "cherries": "🍒", "strawberry": "🍓", "kiwi": "🥝", "mango": "🥭", "Seedling": "🌱", "tree": "🌳", "cactus": "🌵", "tulip": "🌷", "rose": "🌹", "hibiscus": "🌺", "sunflower": "🌻", "blossom": "🌼", "herb": "🌿", "clover": "🍀" }

//Helper function to easily add a new element
export function getEl(selector)
{
    return document.querySelector(selector)
}
export function newEl(tag, classArr, stylesObj, attributes, data)
{
    const el = document.createElement(tag)
    //add the classes
    if (classArr)
    {
        for (const className of classArr)
        {
            el.classList.add(className)
        }
    }
    //Set the styles
    if (stylesObj)
    {
        for (const prop in stylesObj)
        {
            const val = stylesObj[prop]
            el.style.setProperty(prop, val)
        }
    }
    //set the element attributes
    if (attributes)
    {
        for (const attr in attributes)
        {
            const val = attributes[attr]
            el[attr] = val
        }
    }
    //Populate the dataset if data exists
    if (data)
    {
        for (const dataAttr in data)
        {
            el.dataset[dataAttr] = data
        }
    }
    return el
}

export function generatedNameToReadableFormat(generatedName)
{
    //The generated name consists of three hexadecimal numbers, each of 2 digits
    //the first two digits reperesent the index for the adjectives100 array
    const adjectiveIndex = parseInt(generatedName[0] + generatedName[1], 16)
    //the next two digits reperesent the index for the colors50 array
    const colorIndex = parseInt(generatedName[2] + generatedName[3], 16)
    //the final two digits reperesent the index for the items110 array
    const itemIndex = parseInt(generatedName[4] + generatedName[5], 16)
    //In total there are 100 * 50 * 110 = 5.5×10⁵ peers that can join one room
    //
    const readableName = adjectives100[adjectiveIndex] + " " + colors50[colorIndex] + " " + items110[itemIndex]
    return readableName
}

export function setCookie(name, value)
{
    let expiryDate = new Date()

    // set the expiry date 400 days in the future
    // 24 * 60 * 60 * 1000 is the number of millisecond in a day
    expiryDate.setTime(new Date().getTime() + 400 * 24 * 60 * 60 * 1000)

    document.cookie = `${name}=${btoa(value)};expires=${expiryDate}`
}



export function getCookie(name)
{
    let nameAndEqual = name + "="
    let decodedCookie = decodeURIComponent(document.cookie);
    let cookies = decodedCookie.split(";")
    for (let i = 0; i < cookies.length; i++)
    {
        // remove any starting or trailing whitespaces
        cookies[i] = cookies[i].trim()
        // if the string starts with the name
        if (nameAndEqual == cookies[i].slice(0, nameAndEqual.length))
        {
            //value is rest of string
            let value = atob(cookies[i].slice(nameAndEqual.length))
            //set cookie again such that expiry date is renewed
            setCookie(name, value)
            return value
        }
    }
    return ""
}

export function toggleTheme()
{
    let original = getCookie("theme")
    if (original == "dark")
    {
        setCookie("theme", "light")
    } else
    {
        setCookie("theme", "dark")
    }
    refreshTheme()
}

export function refreshTheme()
{
    if (getCookie("theme") == "dark")
    {
        document.documentElement.classList.add("dark")
    } else
    {
        document.documentElement.classList.remove("dark")
    }
}

//manage theme
refreshTheme()
document.addEventListener("DOMContentLoaded", (event) =>
{
    document.querySelectorAll(".toggle-theme-icon").forEach(el => el.onclick = () => toggleTheme())
})

const pearsonPermutation = [225, 156, 253, 229, 82, 136, 206, 9, 74, 114, 211, 244, 178, 58, 99, 14, 51, 165, 239, 110, 179, 142, 131, 194, 36, 232, 49, 35, 95, 129, 223, 122, 227, 29, 163, 224, 87, 199, 198, 62, 130, 56, 234, 215, 155, 115, 170, 107, 120, 90, 44, 140, 175, 84, 32, 40, 65, 28, 182, 138, 241, 137, 70, 127, 151, 168, 21, 141, 103, 5, 255, 79, 148, 61, 98, 10, 112, 118, 30, 83, 121, 149, 81, 167, 27, 85, 181, 94, 196, 78, 166, 134, 108, 133, 38, 184, 236, 213, 52, 105, 252, 26, 187, 60, 59, 230, 164, 100, 69, 47, 8, 106, 31, 144, 161, 240, 15, 116, 55, 132, 157, 209, 86, 25, 180, 1, 233, 102, 12, 93, 201, 152, 13, 226, 67, 158, 135, 24, 183, 92, 207, 18, 16, 218, 64, 208, 150, 177, 185, 172, 113, 3, 6, 153, 123, 124, 7, 217, 89, 125, 66, 139, 189, 169, 173, 117, 147, 20, 221, 126, 251, 101, 4, 228, 39, 77, 247, 91, 245, 111, 202, 53, 143, 33, 176, 237, 219, 205, 104, 250, 96, 254, 231, 235, 216, 72, 195, 0, 162, 174, 57, 11, 220, 128, 73, 75, 242, 249, 63, 42, 54, 71, 192, 222, 171, 19, 191, 76, 46, 188, 41, 210, 97, 154, 197, 34, 246, 68, 88, 212, 119, 200, 243, 50, 45, 145, 48, 23, 248, 186, 159, 37, 203, 214, 17, 80, 238, 2, 146, 193, 22, 190, 204, 160, 109, 43]

export function hashString(string, hash)
{
    // implementation of the pearson hash algorithm
    string = string || ""
    hash = hash || 0
    for (let i = 0; i < string.length; i++)
    {
        hash = pearsonPermutation[hash ^ (string.charCodeAt(i) % 256)];
    }
    return hash
}

export function stringToHues(string)
{
    hue0 = hashString(string, 0)
    hue1 = hashString(string, hue0)
    hue2 = hashString(string, hue1)
    return [hue0, hue1, hue2];
}

export function customPrompt(title, text)
{
    let resolver = null
    const result = new Promise((resolve) => resolver = val => resolve(val))
    $f7.dialog.prompt(text, title, resolver, resolver)
    return result
}

export function customAlert(title, text)
{
    let resolver = null
    const result = new Promise((resolve) => resolver = val => resolve(val))
    $f7.dialog.alert(text, title, resolver)
    return result
}

export function customConfirm(title, text, buttonNames)
{
    let buttons = []
    let resolver = null
    const result = new Promise((resolve) => resolver = val => resolve(val))
    for (let i = 0; i < buttonNames.length; i++)
    {
        const name = buttonNames[i]
        buttons.push({
            text: name,
            onClick: () =>
            {
                resolver(i)
            }
        })
    }
    $f7.dialog.create({
        title,
        text,
        buttons
    }).open()
    return result
}

export function eventPromise(object, event, timeout)
{
    // set default timeout to 10 seconds
    timeout = timeout | 0;
    let resolver = () => { }
    let rejecter = () => { }
    let promise = new Promise((resolve, reject) =>
    {
        resolver = resolve;
        rejecter = reject
    })
    // some manage events with the 'on' funtion, others with 'addEventListener'
    const onevent = (data) =>
    {
        resolver(data)
    }
    if (object.on)
    {
        object.on(event, onevent)
        promise.then(()=>{object.off(event,onevent)})

    } else
    {
        const el = object.addEventListener(event,onevent )
        //Remove event listener just to save space
        promise.then(()=>{object.removeEventListener(event,onevent )})
    }
    if (timeout > 0)
    {
        // set a timeout
        window.setTimeout(() =>
        {
            rejecter("Sorry, Connection timed out");
        }, timeout)
    }
    return promise
}


export function generateUniqueID()
{
    if(crypto && crypto.randomUUID)
    {
        return crypto.randomUUID();
    }
    //else : 
    //the chances of a collision should be very very low, so the id is considered unique
    //Number.toString(36) turns the number into a base 36 string
    //String.substring(2) removes the first 2 characters from the string
    //Effectively removing the "0."
    let id = Date.now().toString(36) + Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2)
    //Generate a string of exactly 30 characters
    return id.padStart(30).slice(0, 30)

}
export async function sha512(str) {
    return bytesToText( await crypto.subtle.digest("SHA-512", new TextEncoder("utf-8").encode(str)))
    
}

export function bytesToText(arrayBuffer)
{
    const byteArr = new Uint8Array(arrayBuffer)
    return String.fromCharCode(...byteArr)
}

export function decodeUint8(uint8Array)
{
    return new TextDecoder("utf-8").decode(uint8Array)
}

export function uintToByteArr(int)
{
    //Convert number to four byte byte array
    let byteArr = new Uint8Array(new ArrayBuffer(4))
    const byteNo = 4
    const divider = 256
    for (let i = 0; i < byteNo; i++)
    {
        //This might look strange, but js follows the litte endian format
        byteArr[i] = int % divider
        int = Math.trunc(int / divider)
    }
    return byteArr
}
export async function downloadFile(file)
{
    const link = URL.createObjectURL(file)
    await customConfirm("Camera media ready.","Choose from ...",["download","discard"])
    const a = newEl("a", [], {}, { href: link, download: file.name })
    a.click()
}
export function byteArrToUint(byteArr)
{
    const multiplier = 256
    let result = 0
    for (byte of byteArr)
    {
        result = result * multiplier + byte
    }
}

export async function error(error)
{
    await customAlert("Error",error)
}

export function wait(ms)
{
    let resolver
    let promise = new Promise((resolve) => resolver = resolve)
    setTimeout(() => resolver(), ms)
    return promise

}

export async function getScript(src)
{
    const script = newEl("script", [], {}, {
        src
    })
    document.body.append(script)
    await eventPromise(script, "load")
}

export function setPeerIcon(iconEl, name)
{
    let nameArr = name.split(" ")
    iconEl.style.background = nameArr[1]
    iconEl.innerText = itemToEmoji[nameArr[2]]
}

export function getReadableFileSize(sizeInBytes, precision)
{
    const suffixes = ["B", "KB", "MB", "GB"]
    for (let i = 0; i < suffixes.length; i++)
    {
        if (sizeInBytes < 1000)
        {
            return String(sizeInBytes.toPrecision(precision)) + suffixes[i]
        }
        sizeInBytes /= 1000
    }
    // If the file size is larger than 1000 of the largest unit
    return String((sizeInBytes * 1000).toPrecision(precision)) + suffixes.at(-1)
}


export function getCurrentTime()
{
    const today = new Date(Date.now())
    return today.toLocaleDateString() + " : " + today.toLocaleTimeString()
}

export function emptyEl(el)
{
    //while elements left
    while (el.children.length > 0)
    {
        //remove one element
        el.removeChild(el.children[0])
    }
}

//classes

export class FileManager
{
    constructor(dropAreaEl, containerEl, addFileButton, selectionCounterEl, selectAllCheckbox)
    {

        // a set to store all the files added
        this.files = new Set()
        //The container element holding the file previews
        this.containerEl = containerEl
        //The element that accepts files dropped on it
        this.dropAreaEl = dropAreaEl
        //The element that display the count of selected files
        this.selectionCounterEl = selectionCounterEl
        this.selectAllCheckbox = selectAllCheckbox
        //style the file manager
        containerEl.classList.add("grid")
        //note that event.stopPropagation(); and event.preventDefault();
        //is needed in all three of ondragover,ondragenter,ondrop
        containerEl.ondragstart = (event) =>
        {
            this.highlight()
        }
        dropAreaEl.ondragover = (event) =>
        {
            event.stopPropagation();
            event.preventDefault();
            this.highlight()
        }
        dropAreaEl.ondragenter = (event) =>
        {
            event.stopPropagation();
            event.preventDefault();
            this.highlight()
        }


        dropAreaEl.ondragleave = (event) =>
        {
            event.stopPropagation();
            event.preventDefault();
            this.unhighlight()
        }

        dropAreaEl.ondrop = (event) =>
        {
            event.stopPropagation();
            event.preventDefault();
            this.ondrop(event);
            this.unhighlight()
        }
        this.fileInput = newEl("input", ["display-none"], {}, {
            type: "file",
            multiple: true
        })
        //connect button to file input
        addFileButton.onclick = () =>
        {
            this.fileInput.click()
        }
        //watch for files being input through the input element
        this.fileInput.onchange = () =>
        {
            this.openFiles(this.fileInput.files)
            this.fileInput.files = null
        }


        containerEl.appendChild(this.fileInput)
        //count how many files are selected
        this.selectedCount = 0
        //Watch for clicks on the checkbox
        this.selectAllCheckbox.onclick = () =>
        {
            this.selectAll()
        }
    }
    highlight()
    {
        this.dropAreaEl.classList.add("drop-area-active")
    }
    unhighlight()
    {
        this.dropAreaEl.classList.remove("drop-area-active")
    }
    ondrop(event)
    {
        this.openFiles(event.dataTransfer.files)
    }
    openFiles(files)
    {
        for (const file of files)
        {
            const fileCard = newEl("div", ["file", "card"],)
            const fileIcon = newEl("div", ["file-icon"])
            // Check for file type
            const type = file.type.split("/")[0].trim()
            if (type == "image")
            {
                fileIcon.style.backgroundImage = `url(${URL.createObjectURL(file)})`
            } else
            {
                const icon = newEl("i", ["material-icons", "md-only", "large-icon"], {}, {
                    innerHTML: "description"
                })
                fileIcon.appendChild(icon)
            }
            let fileName = file.name + "(" + getReadableFileSize(file.size, 3) + ")"
            //shorten file name to a maximum of 35 characters, excluding newline
            //Wrap file name around to next line if needed
            if (fileName.length > 18)
            {
                if (fileName.length > 35)
                {
                    fileName = fileName.slice(0, 16) + "...." + fileName.slice(fileName.length - 16)
                }
                fileName = fileName.slice(0, 18) + "\n" + fileName.slice(18)
            }
            const label = newEl("label", [], {}, {
                innerText: fileName
            })

            //add badge to show when file is selected
            let badge = newEl("span", ["badge", "color-green", "display-none"])
            let icon = newEl("i", ["material-icons", "md-only"], {}, {
                innerHTML: "check"
            })
            badge.appendChild(icon)
            fileCard.append(fileIcon, label, badge)
            this.containerEl.appendChild(fileCard)
            //Store the file data for future reference.
            //This is a shorthand way of definig a js object
            const fileData = {
                file,
                fileCard,
                badge,
                selected: false
            }
            this.files.add(fileData)
            // Set click handler
            fileCard.onclick = () => this.selectFile(fileData)
        }
        //If the checkbox has been checked
        if (this.selectAllCheckbox.checked == true)
        {
            this.selectAll()
        }
    }
    displaySelectedCount()
    {
        if (this.selectedCount == 0)
        {
            this.selectionCounterEl.innerText = "none"
        } else
        {
            this.selectionCounterEl.innerText = this.selectedCount
        }
    }
    selectFile(fileData)
    {
        if (fileData.selected == false)
        {
            fileData.selected = true
            //change card color
            fileData.fileCard.classList.add("color-lime")
            fileData.badge.classList.remove("display-none")
            fileData.fileCard.onclick = () => this.deselectFile(fileData)
            this.selectedCount++
            this.displaySelectedCount()
        }
    }

    deselectFile(fileData)
    {
        if (fileData.selected == true)
        {
            fileData.selected = false
            //change card color
            fileData.fileCard.classList.remove("color-lime")
            fileData.badge.classList.add("display-none")
            fileData.fileCard.onclick = () => this.selectFile(fileData)
            this.selectedCount--
            this.displaySelectedCount()
            //A file was deselected meaning that not all files are selected
            this.selectAllCheckbox.checked = false
        }
    }
    selectAll()
    {
        if (this.selectAllCheckbox.checked)
        {
            //if checkbox checked
            for (const fileData of this.files)
            {
                this.selectFile(fileData)
            }
        } else
        {
            for (const fileData of this.files)
            {
                this.deselectFile(fileData)
            }
        }
    }
    getAllFiles()
    {
        let files = new Set()
        for (const fileData of this.files)
        {
            files.add(fileData.file)
        }
        return files
    }
    getSelectedFiles()
    {
        let files = new Set()
        for (const fileData of this.files)
        {
            if (fileData.selected)
            {
                files.add(fileData.file)
            }
        }
        return files
    }

}



export class CustomNotification
{
    static notificationCount = 0
    static openPannelButton = null
    constructor(peerName, activeTime, notificationsPanel, openPannelButton, notificationOnclick)
    {
        //The element where the notification is kept once it is hidden
        this.notificationStoreEl = notificationsPanel.el
        //the notification panel
        this.notificationsPanel = notificationsPanel
        //The button that opens the notification pannel
        CustomNotification.openPannelButton = openPannelButton
        //The time after which the notification automatically closes
        this.activeTime = activeTime
        this.notificationEl = newEl("div", ["flex", "flex-row", "notification"])
        //The name and icon of the peer that triggered the notification
        this.peerName = peerName

        this.peerDataEl = newEl("div", ["flex", "flex-column", "align-items-center", "justify-content-center"])
        this.icon = newEl("div", ["circle-icon", "margin-10px"])
        setPeerIcon(this.icon, peerName)

        this.peerNameEl = newEl("label", ["margin-10px"], {}, {
            innerText: peerName
        })
        //append the peer icon and name
        this.peerDataEl.append(this.icon, this.peerNameEl)

        this.contentEl = newEl("div", ["flex", "flex-column"], {
            flexGrow: '2'
        })
        this.notificationEl.append(this.peerDataEl, this.contentEl)

        if (notificationOnclick)
        {
            this.notificationEl.onclick = () => notificationOnclick()
        }
        else
        {
            this.notificationEl.onclick = () => this.showNotificationPannel()
        }

        this.notification = $f7.notification.create({
            el: this.notificationEl,
            on: {
                close: () => this.onclose()
            }
        })
        CustomNotification.notificationCount++
        CustomNotification.updateCountDisplay()
        CustomNotification.openPannelButton.onclick = () => this.showNotificationPannel()


    }
    open()
    {
        if (this.timeout)
        {
            clearTimeout(this.timeout)
        }

        this.notificationEl.classList.add("notification")
        this.notificationEl.classList.remove("card")
        this.contentEl.classList.remove("card")

        this.notification.open()
        this.timeout = window.setTimeout(() => this.notification.close(), this.activeTime)
    }
    displayProgressbar(text, isInfiniteProgressbar)
    {
        this.text = newEl("p", [], {}, {
            innerText: text
        })
        this.progressEl = newEl("div")
        if (isInfiniteProgressbar)
        {
            this.progressEl.classList.add("progressbar-infinite")
        } else
        {
            this.progressEl.classList.add("progressbar")
            this.progressEl.dataset.progress = 0
        }
        this.progressLabel = newEl("label", [], {}, {
            innerText: '0%'
        })
        emptyEl(this.contentEl)
        this.contentEl.append(this.text, this.progressLabel, this.progressEl)
        this.open()
    }
    setProgress(progress, otherText)
    {
        progress = progress.toPrecision(3)
        $f7.progressbar.set(this.progressEl, progress)
        this.progressLabel.innerText = progress + "%, " + otherText
    }
    displayText(text)
    {
        //truncate long text
        if (text.length > 100)
        {
            text = text.slice(0,100) + "..."
        }
        this.text = newEl("p", [], {}, {
            innerText: text
        })
        emptyEl(this.contentEl)
        this.contentEl.append(this.text)
        this.open()
    }
    onclose()
    {

        if (this.timeout)
        {
            clearTimeout(this.timeout)
        }
        this.notificationEl.classList.remove("notification")
        this.notificationEl.classList.add("card")
        this.contentEl.classList.add("card")
        this.notificationStoreEl.prepend(this.notificationEl)
    }
    showNotificationPannel()
    {
        this.notification.close();
        this.notificationsPanel.open()
        CustomNotification.notificationCount = 0
        CustomNotification.updateCountDisplay()
    }
    static updateCountDisplay()
    {
        const button = CustomNotification.openPannelButton
        let badge = button.querySelector(".count-badge")
        //If badge does not exist
        if (!badge)
        {
            badge = newEl("label", ["count-badge", "badge"])
            button.append(badge)
            //This is needed to place the badge at the correct position
            button.style.position = "relative"
        }
        badge.innerText = CustomNotification.notificationCount
        if (CustomNotification.notificationCount == 0)
        {
            //If no notification don't show badge
            badge.style.display = "none"
        } else
        {
            badge.style.display = "block"
        }
    }
}

// A class that provides a wrapper to the indexedDB api
export class Database
{
    constructor(databaseName, objectStores)
    {
        // open the database
        this.openRequest = indexedDB.open(databaseName, 1);
        //this event is fired only once when database is created
        this.openRequest.onupgradeneeded = (event) => this.initialize(event)
        this.openRequest.onsuccess = (event) => this.startConnection(event)
        //store the object stores foe future reference
        this.objectStores = objectStores
        this.transaction = null
        // "this" inside an arrow function is the same as "this" outside it
        this.connectionStarted = new Promise((resolve) =>
        {
            this.connectionStartedResolver = resolve
        })
    }
    initialize(event)
    {
        // Initialize database structure
        this.database = this.openRequest.result
        for (var i = 0; i < this.objectStores.length; i++)
        {
            this.openRequest.result.createObjectStore(this.objectStores[i], {
                keyPath: 'id'
            });
        }
        this.connectionStartedResolver()
    }
    startConnection(event)
    {
        this.database = this.openRequest.result
        this.connectionStartedResolver()
    }
    startTransaction()
    {
        if (!this.transaction)
        {
            this.transaction = this.database.transaction(this.objectStores, "readwrite")
            this.transaction.oncomplete = () =>
            {
                this.transaction = null
            }
            this.transaction.onabort = () =>
            {
                this.transaction = null
            }
            this.transaction.onerror = () =>
            {
                this.transaction = null
            }

        }
    }
    async setItem(id, objectStoreName, data)
    {
        // Wait until the db is connected
        await this.connectionStarted
        this.startTransaction()
        var objectStore = this.transaction.objectStore(objectStoreName)
        return objectStore.put({
            id: id,
            data: data
        })
    }
    async deleteItem(id, objectStoreName)
    {
        // Wait until the db is connected
        await this.connectionStarted
        this.startTransaction()
        var objectStore = this.transaction.objectStore(objectStoreName)
        return objectStore.delete(id)
    }
    async deleteObjectStore(objectStoreName)
    {
        // Wait until the db is connected
        await this.connectionStarted
        this.startTransaction()
        var objectStore = this.transaction.objectStore(objectStoreName)
        return objectStore.clear()
    }
    async getItem(id, objectStoreName)
    {
        await this.connectionStarted
        this.startTransaction()
        var objectStore = this.transaction.objectStore(objectStoreName)
        var resultObj = await (objectStore.get(id))
        var completed = new Promise((resolve) => resultObj.onsuccess = () =>
        {
            resolve()
        })
        await completed
        //If there is a match
        if (resultObj.result)
        {
            return resultObj.result.data
        }
        else
        {
            return undefined
        }
    }

}

export class ChatMessageManager
{

    constructor( chatEl, chatIconEl, mainPeerDisplayEl, peerNames, getUniqueIdOfPeer, sendMessage)
    {
        //the element where the chat menu and the chat messages are shown
        this.chatEl = chatEl
        //The icon that opens the chat menu when clicked
        this.chatIconEl = chatIconEl
        //The element that shows th icons of the peers available
        this.mainPeerDisplayEl = mainPeerDisplayEl
        //the object that maps peerId to peer names
        this.peerNames = peerNames
        //An async function that returns unique id of peer
        this.getUniqueIdOfPeer = getUniqueIdOfPeer
        //a function that sends a message to a peer
        //parameters : message, peerId
        //peerId = "" when no peer is selected
        this.sendMessage = sendMessage
        this.db = new Database("message-data", ["messages", "meta"])
        this.history = {}
        this.historyMetaData = {}
        this.uniqueIds = {}
        this.peerUnreadCounts = {}
        //set current peer to none
        this.currentPeerId = ""
        this.messagesHeader = newEl("div", ["flex", "flex-row", "align-items-center", "justify-content-space-between"], { position: "sticky", top: "60px", height: "60px", "z-index": "10", background: "var(--f7-md-surface-1)" })
        this.messagesContainer = newEl("div", ["messages-content", "overflow-auto"], { position: "relative", "padding-bottom": "150px", "padding-top": "60px" })
        this.peerDisplayHeader = newEl("div", ["flex", "flex-row", "align-items-center", "justify-content-space-between"], { position: "sticky", top: "60px", height: "60px", "z-index": "10", background: "var(--f7-md-surface-1)" })
        this.peerDisplayContainer = newEl("div", ["flex", "flex-row", "flex-wrap"])
        this.messageBar = newEl("div", ["toolbar", "messagebar"], { position: "fixed", bottom: "80px" })
        this.progressBar = newEl("div", ["progressbar", "progressbar-infinite"])
        this.progressBar.append(newEl("span"))
        this.peerDisplayHeader.append(newEl("h1", ["margin-10px"], { width: "100vw", "text-align": "center", "line-height": "20px" }, { innerText: "Available peers" }))
        this.peerDisplayHeader.append(newEl("button", ["button", "button-tonal"], {}, { innerText: "Detete full history", onclick: () => this.deleteHistory() }))
        this.peerDisplayContainer.append(newEl("p", ["show-if-empty", "margin-10px"], {}, { innerText: "No peers avalable to chat with yet. Ask someone in the same network to visit this website." }))
        this.chatEl.append(this.messagesHeader, this.peerDisplayHeader, this.peerDisplayContainer, this.messagesContainer, this.messageBar)

        //this.setUpPeerDisplay()
        this.showPeerDisplay()
        this.showMessageBar()
    }

    async getHistoryOfPeer(peerId)
    {
        //fetch unique id of peer if not already fetched
        if (!this.uniqueIds[peerId])
        {
            this.uniqueIds[peerId] = await this.getUniqueIdOfPeer(peerId)
        }
        const uniqueId = this.uniqueIds[peerId]
        // if history already exists, exit function
        if (this.history[peerId])
        {
            return
        }
        let msgIds = await this.db.getItem(uniqueId, "meta")
        if (!msgIds)
        {
            //Set msgIds to [] if not already defined
            msgIds = []
        }
        //Array to store 
        let messages = []
        for (const msgId of msgIds)
        {
            const message = await this.db.getItem(msgId, "messages")
            messages.push(message)
        }
        // sort in ascdnding order of time
        // newest last
        messages.sort((a, b) => a.time - b.time)
        this.history[peerId] = messages
        this.historyMetaData[peerId] = msgIds
    }

    async showChatContainer(peerId)
    {
        this.peerUnreadCounts[peerId] = 0
        this.showUnreadCounts()
        this.peerDisplayContainer.style.display = "none"
        this.peerDisplayHeader.style.display = "none"
        this.progressBar.style.display = "block"
        if (this.messagesHeader.dataset.id != peerId)
        {
            emptyEl(this.messagesHeader)
            const headerLeft = newEl("div", ["flex", "flex-row", "align-items-center"])
            const returnIcon = newEl("i", ["material-icons", "margin-10px"], {}, { innerHTML: "arrow_back", onclick: () => this.showPeerDisplay() })
            const peerIcon = newEl("div", ["circle-icon"])
            const peerName = this.peerNames[peerId]
            const deleteHistoryIcon = newEl("i", ["material-icons", "margin-10px"], {}, { innerHTML: "delete", onclick: () => this.deleteHistory(peerId) })
            setPeerIcon(peerIcon, peerName)
            const peerNameEl = newEl("p", ["margin-10px"], {}, { innerText: peerName })
            headerLeft.append(returnIcon, peerIcon, peerNameEl)
            this.messagesHeader.append(headerLeft, deleteHistoryIcon)
            this.messagesHeader.dataset.id = peerId
            emptyEl(this.messagesContainer)
            this.messagesContainer.append(newEl("p", ["show-if-empty", "margin-10px"], {}, { innerText: "Messages sent and received will be displayed here" }))
        }
        this.chatEl.append(this.progressBar)
        this.messagesHeader.style.display = "flex"
        await this.getHistoryOfPeer(peerId)
        this.progressBar.style.display = "none"
        this.chatEl.classList.add("messages")
        this.messagesContainer.style.display = "block"
        //If the previously displayed chat was not of this peer
        const history = this.history[peerId]
        console.log(history)
        for (let i = 0; i < history.length; i++)
        {
            //The index i can uniquely identify the message
            //If the message is not already rendered
            if (!this.messagesContainer.querySelector(".m" + i))
            {
                const message = history[i]
                const messageTime = new Date(message.timestamp).toLocaleString()
                let messageEl = newEl("div", ["message", "m" + i])
                if (message.sent == true)
                {
                    messageEl.classList.add("message-sent")
                }
                else
                {
                    messageEl.classList.add("message-received")
                }
                const messageContent = newEl("div", ["message-content"])
                const messageBubble = newEl("div", ["message-bubble"], {}, { innerText: message.text })
                messageBubble.onclick = () =>
                {
                    if (!this.messageBar.querySelector("textarea").value.trim())
                    {
                        //If the text area is empty, copy the message to the text area
                        this.messageBar.querySelector("textarea").value = message.text
                    }
                }
                const messageDate = newEl("div", ["message-text-footer"], {}, { innerText: messageTime })
                messageContent.append(messageBubble, messageDate)
                messageEl.append(messageContent)
                this.messagesContainer.append(messageEl)
            }
        }
        this.currentPeerId = peerId
        $f7.el.scrollTop = $f7.el.scrollHeight;

    }
    async deleteHistory(peerId)
    {
        if (!peerId)
        {
            //if no peerId was passed
            const response = await customConfirm("Delete full chat history", "Are you sure you want to delete chat history for all peers? this action is not reversible", ["No, DO NOT DELETE", "yes, DELETE HISTORY"])
            if (response == 1)
            {
                //If second response, delete all of the peer history
                this.db.deleteObjectStore("messages")
                this.db.deleteObjectStore("meta")
            }
        }
        else
        {
            const response = await customConfirm("Delete chat history for " + this.peerNames[peerId], "Are you sure you want to delete chat history for this peer? this action is not reversible", ["No, DO NOT DELETE", "yes, DELETE PEER HISTORY"])
            if (response == 1)
            {
                if (!this.uniqueIds[peerId])
                {
                    //If the unique id has not been found
                    this.uniqueIds[peerId] = await this.getUniqueIdOfPeer(peerId)
                }
                //If second response, delete all of the peer history
                const uniqueId = this.uniqueIds[peerId]
                const messageIds = this.db.getItem(uniqueId, "meta")
                for (const messageId in messageIds)
                {
                    this.db.deleteItem(messageId, "messages")
                }
                this.db.deleteItem(uniqueId, "meta")
                this.history[peerId] = {}
                if (peerId == this.currentPeerId)
                {
                    emptyEl(this.messagesContainer)
                    this.showChatContainer(peerId)
                }
            }
        }
    }
    showMessageBar()
    {
        //this.messageBar is defined in the constructor
        const toolBarInner = newEl("div", ["toolbar-inner"])
        const messageBarArea = newEl("div", ["messagebar-area", "flex", "flex-row"])
        const textarea = newEl("textarea", [], {}, { placeholder: "message" })
        const clearIconLink = newEl("a", ["link", "circle-icon"])
        clearIconLink.onclick = () => textarea.value = ""
        const clearIcon = newEl("i", ["material-icons"], {}, { innerHTML: "close" })
        const sendIconLink = newEl("a", ["link", "circle-icon"])
        const sendMessage = () =>
        {
            //If the value is not just some whitespace
            if (textarea.value.trim())
            {
                this.sendMessage(textarea.value, this.currentPeerId)
                textarea.value = ""
            }
        }
        textarea.addEventListener('keydown', (event) => { if (event.ctrlKey && event.key == 'Enter') { sendMessage() } })
        sendIconLink.onclick = sendMessage
        const sendIcon = newEl("i", ["material-icons"], {}, { innerHTML: "send" })
        clearIconLink.append(clearIcon)
        sendIconLink.append(sendIcon)
        messageBarArea.append(textarea, clearIconLink, sendIconLink)
        toolBarInner.append(messageBarArea)
        this.messageBar.append(toolBarInner)
    }
    setUpPeerDisplay()
    {
        let templates = this.mainPeerDisplayEl.childNodes
        for (const template of templates)
        {
            const peerId = template.dataset.id
            //If the icon has not been displayed already 
            //And it is not the loader
            if (peerId && !this.peerDisplayContainer.querySelector(".p" + peerId))
            {
                const icon = template.cloneNode(true)
                icon.onclick = () => this.showChatContainer(peerId)
                this.peerDisplayContainer.append(icon)
                this.peerUnreadCounts[peerId] = 0
            }
        }
    }

    showPeerDisplay()
    {
        this.peerDisplayContainer.style.display = "flex"
        this.peerDisplayHeader.style.display = "flex"
        this.messagesContainer.style.display = "none"
        this.messagesHeader.style.display = "none"
        this.currentPeerId = ""
    }
    showUnreadCounts()
    {
        let total = 0
        for (const peerId in this.peerUnreadCounts)
        {
            const count = this.peerUnreadCounts[peerId]
            const icon = this.peerDisplayContainer.querySelector(".p" + peerId)
            if (icon)
            {
                //If such an icon exists
                let badge = icon.querySelector("label.badge")
                if (!badge)
                {
                    badge = newEl("label", ["badge"])
                    icon.append(badge)
                }
                if (count != 0)
                {
                    badge.innerText = count
                    badge.style.display = "block"
                }
                else
                {
                    badge.style.display = "none"
                }
            }
            total += count
        }
        let badge = this.chatIconEl.querySelector("label.badge")
        if (!badge)
        {
            badge = newEl("label", ["badge"])
            this.chatIconEl.appendChild(badge)
        }
        if (total != 0)
        {
            badge.innerText = total
            badge.style.display = "block"
        }
        else
        {
            badge.style.display = "none"
        }
    }
    async addMessage(peerId, message, sent)
    {
        console.log(sent)
        await this.getHistoryOfPeer(peerId)
        const timestamp = Date.now()
        const messageId = generateUniqueID()
        const messageObj = { sent, timestamp, text: message }
        await this.db.setItem(messageId, "messages", messageObj)
        this.historyMetaData[peerId].push(messageId)
        await this.db.setItem(this.uniqueIds[peerId], "meta", this.historyMetaData[peerId])
        this.history[peerId].push({ sent, timestamp, text: message })
        //if the chat window is open
        if (this.currentPeerId == peerId)
        {
            this.showChatContainer(peerId)
        }
        else
        {
            //if the message was received
            if (!sent)
            {
                if (this.peerUnreadCounts[peerId])
                {
                    //Increment if already initialized
                    this.peerUnreadCounts[peerId]++
                }
                else
                {
                    //initialize
                    this.peerUnreadCounts[peerId] = 1
                }
                this.showUnreadCounts()
            }
        }
    }

}



export class CameraManager
{
    //constants to store the values of the signals
    static controls =
        {
            SWITCH_CAMERA: "swc",
            START_RECORD: "srr",
            STOP_RECORD: "str",
            TAKE_PHOTO: "tkp",
            PHOTO_TAKEN: "ptn",
            RECORDING_STARTED: "rsr",
            RECORDING_STOPPED: "rst",
            CLOSE_CONNECTION: "ccn"
        }

    constructor(videoEl, takePhotoButton, recordButton, switchCameraButton, exitCameraButton, sendStream, sendControlMessage)
    {
        //The <video> element that will display camera input from either
        //the peer or the device
        this.videoEl = videoEl
        videoEl.setAttribute('playsinline', '');
        videoEl.setAttribute('autoplay', '');
        videoEl.setAttribute('muted', '');
        videoEl.muted = true
        videoEl.style.display = "none"
        this.takePhotoButton = takePhotoButton
        this.recordButton = recordButton
        this.switchCameraButton = switchCameraButton
        this.exitCameraButton = exitCameraButton
        exitCameraButton.style.display = "none"
        exitCameraButton.onclick = () => this.exitCamera()
        this.facingMode = 'environment'
        this.recorder = null
        this.isSharing = false
        this.currentPeerId = ''
        //Function that sends video stream, parameters : stream,peerId
        this.sendStream = sendStream
        //Function that sends control message, parameters : message,peerId
        this.sendControlMessage = sendControlMessage

        takePhotoButton.onclick = () => this.takePhoto()
        switchCameraButton.onclick = () => this.switchCamera()
        recordButton.onclick = () =>
        {
            if (recordButton.classList.contains("recording-animation"))
            {
                //Recording is taking place
                this.stopRecording()
            }
            else
            {
                this.startRecording()
            }
        }
        this.disableButtons()
    }

    async shareStream(peerId)
    {
        if (this.stream)
        {
            this.endStream()
        }
        this.stream = await navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: this.facingMode
            }, audio: true
        });

        this.isSharing = true
        this.currentPeerId = peerId
        this.attachStreamToPlayer()
        this.sendStream(this.stream, peerId)
    }
    async connectToPeerStream(stream, peerId)
    {
        if (this.stream)
        {
            this.endStream()
        }
        this.stream = stream
        this.isSharing = false
        this.attachStreamToPlayer()
        this.currentPeerId = peerId
    }
    attachStreamToPlayer()
    {
        this.enableButtons()
        this.videoEl.srcObject = this.stream
        this.videoEl.style.display = "block"
        this.exitCameraButton.style.display = "block"
    }
    exitCamera()
    {
        this.sendControlMessage(CameraManager.controls.CLOSE_CONNECTION, this.currentPeerId)
        this.endStream()
    }
    endStream()
    {
        this.disableButtons()
        this.stream.getTracks().forEach(track => track.stop())
        this.stream.stop()
        this.stream = null
        this.videoEl.style.display = "none"
        this.exitCameraButton.style.display = "none"
        this.videoEl.srcObject = undefined
        this.currentPeerId = ""
    }

    switchCamera()
    {
        if (this.isSharing)
        {
            //This device's camera is being shared
            if (this.facingMode == 'environment')
            {
                this.facingMode = 'user'
            }
            else
            {
                this.facingMode = 'environment'
            }
            this.shareStream(this.currentPeerId)
        }
        else
        {
            this.sendControlMessage(CameraManager.controls.SWITCH_CAMERA, this.currentPeerId)
        }
    }

    async takePhoto()
    {
        const name = CameraManager.getMediaName() + ".png"
        if (this.isSharing)
        {
            const width = this.videoEl.videoWidth
            const height = this.videoEl.videoHeight
            const canvas = newEl("canvas", [], {}, { width, height })
            const ctx = canvas.getContext("2d")
            ctx.drawImage(this.videoEl, 0, 0, width, height)
            const blob = await CameraManager.canvasToBlob(canvas)
            const file = new File([blob], name, { lastModified: Date.now() });
            downloadFile(file)
            this.sendControlMessage(CameraManager.controls.PHOTO_TAKEN, this.currentPeerId)
        }
        else
        {
            this.sendControlMessage(CameraManager.controls.TAKE_PHOTO, this.currentPeerId)
            CameraManager.disableEl(this.takePhotoButton)
        }
    }

    startRecording()
    {
        if (this.isSharing && !this.recorder)
        {
            //Video input is to be taken from the current device
            this.recorder = new RecordRTCPromisesHandler(this.stream, {
                type: 'video'
            });

            this.recorder.startRecording()
            this.sendControlMessage(CameraManager.controls.RECORDING_STARTED, this.currentPeerId)
            //Show the recording animation
            this.recordButton.classList.add("recording-animation")
        }
        else
        {
            this.sendControlMessage(CameraManager.controls.START_RECORD, this.currentPeerId)
            CameraManager.disableEl(this.recordButton)
        }

    }

    async stopRecording()
    {
        const name = CameraManager.getMediaName() + ".webm"
        if (this.isSharing)
        {
            //Video input is to be taken from the current device
            await this.recorder.stopRecording();
            let blob = await this.recorder.getBlob();
            const file = new File([blob], name, { lastModified: Date.now() });
            downloadFile(file)
            this.sendControlMessage(CameraManager.controls.RECORDING_STOPPED, this.currentPeerId)
            //Remove recording animation 
            this.recordButton.classList.remove("recording-animation")
            //Remove recorder to allow future recordings
            this.recorder = undefined
        }
        else
        {
            this.sendControlMessage(CameraManager.controls.STOP_RECORD, this.currentPeerId)
            CameraManager.disableEl(this.recordButton)
        }
    }

    static getMediaName()
    {
        let mediaCount = 0
        let mediaCountStr = getCookie("mediaCount")
        if (mediaCountStr)
        {
            mediaCount = parseInt(mediaCountStr) + 1
        }
        setCookie("mediaCount", String(mediaCount))
        return mediaCount.toString(36).padStart(7, "0")
    }

    handleControlMessages(message)
    {
        console.log(message)
        if (this.isSharing)
        {
            if (message == CameraManager.controls.TAKE_PHOTO)
            {
                this.takePhoto()
            }
            else if (message == CameraManager.controls.START_RECORD)
            {
                this.startRecording()
            }
            else if (message == CameraManager.controls.STOP_RECORD)
            {
                this.stopRecording()
            }
            else if (message == CameraManager.controls.SWITCH_CAMERA)
            {
                this.switchCamera()
            }
        }
        else
        {
            if (message == CameraManager.controls.PHOTO_TAKEN)
            {
                //Show toast
                $f7.toast.create({ text: "photo taken", closeTimeout: 1000, destroyOnClose: true }).open()
                CameraManager.enableEl(this.takePhotoButton)

            }
            else if (message == CameraManager.controls.RECORDING_STARTED)
            {
                this.recordButton.classList.add("recording-animation")
                CameraManager.enableEl(this.recordButton)
            }
            else if (message == CameraManager.controls.RECORDING_STOPPED)
            {
                this.recordButton.classList.remove("recording-animation")
                CameraManager.enableEl(this.recordButton)
            }
        }
        if (message == CameraManager.controls.CLOSE_CONNECTION)
        {
            this.endStream()
        }

    }
    static enableEl(el)
    {
        el.disabled = false
        el.classList.remove("disabled")
    }

    static disableEl(el)
    {
        el.disabled = true
        el.classList.add("disabled")
    }

    enableButtons()
    {
        CameraManager.enableEl(this.takePhotoButton)
        CameraManager.enableEl(this.switchCameraButton)
        CameraManager.enableEl(this.recordButton)
    }
    disableButtons()
    {
        CameraManager.disableEl(this.takePhotoButton)
        CameraManager.disableEl(this.switchCameraButton)
        CameraManager.disableEl(this.recordButton)
    }

    static canvasToBlob(canvas)
    {
        let resolve
        const promise = new Promise((r) => resolve = r)
        canvas.toBlob((blob) => resolve(blob))
        return promise
    }
}

export class TourGuide{
    constructor(attractionsArr){
        this.attractionsArr = attractionsArr
        this.index = -1
    }
    
    next()
    {
        //as long as the current index is not that of the last element
        if (this.index < this.attractionsArr.length - 1)
        {
            if (this.index >= 0)
            {
                //close the previous attraction
                this.attractionsArr[this.index].close()
            }
            this.index++
            //The expression is true if this.index <= 0, meaning this is the first attraction
            let withoutPrevious = this.index <= 0 
            //The expression is true if this.index + 1 >= this.attractionsArr.length, ie this is the last attraction
            let withoutNext = this.index + 1 >= this.attractionsArr.length
            //open the next
            this.attractionsArr[this.index].open(this,true,withoutPrevious,withoutNext)
        }
        else
        {
            this.exit()
        }
    }
    previous()
    {
        if(this.index > 0)
        {
            if (this.index < this.attractionsArr.length)
            {
                //close the previously opened attraction
                this.attractionsArr[this.index].close()
            }
    
            this.index--
            //The expression is true if this.index <= 0, meaning this is the first attraction
            let withoutPrevious = this.index <= 0 
            //The expression is true if this.index + 1 >= this.attractionsArr.length, ie this is the last attraction
            let withoutNext = this.index + 1 >= this.attractionsArr.length
            this.attractionsArr[this.index].open(this,false,withoutPrevious,withoutNext)
        }
        else
        {
            this.exit()
        }
    }
    exit()
    {
        this.attractionsArr[this.index].close()
    }
}
export class TourAttraction
{
    constructor(connectedElSelector,text,tabId)
    {
        this.connectedEl = getEl(connectedElSelector)
        this.text = text
        this.tabId = tabId
    }
    open(guide,movingForwards,withoutPrevious,withoutNext)
    {
        if (!this.connectedEl)
        {
            if(movingForwards)
            {
                guide.next()
            }
            else
            {
                guide.previous()
            }
        }
        else
        {
            const headingStr = `slide ${guide.index + 1} / ${guide.attractionsArr.length} slides`
            $f7.tab.show("#" + this.tabId)
            this.popover = newEl("div", ["popover"])
            const popoverArrow = newEl("div", ["popover-arrow"],{"z-index":"1001"})
            const popoverInner = newEl("div", ["popover-inner","flex","flex-column"],{"z-index":"1001"})
            const heading = newEl("a",["margin-10px"], {}, {innerText:headingStr})
            const text = newEl("p",["margin-10px"], {}, {innerText:this.text})
            const buttonContainer = newEl("div", ["flex", "flex-row"])
            if (!withoutPrevious)
            {
                const prevButton = newEl("button", ["button", "button-tonal", "margin-10px"], {}, {innerText : "< previous", onclick : ()=>guide.previous()})
                buttonContainer.append(prevButton)
            }
            if (!withoutNext)
            {
                const nextButton = newEl("button", ["button", "button-tonal", "margin-10px"], {}, {innerText : "next >",onclick : ()=>guide.next()})
                buttonContainer.append(nextButton)
            }
            const exitButton = newEl("button", ["button", "button-tonal"], {}, {innerText : "exit tour",onclick : ()=>guide.exit()})
            popoverInner.append(heading,text,exitButton,buttonContainer)
            this.popover.append(popoverArrow, popoverInner)
            this.$f7Popover = $f7.popover.create({el:this.popover, targetEl:this.connectedEl, closeByBackdropClick:false, closeByOutsideClick:false})
            this.$f7Popover.backdropEl.onclick = ()=>guide.next()
            this.$f7Popover.open()
        }
    }

    close()
    {
        if(this.$f7Popover)
        {
            this.popover.remove()
            this.$f7Popover.close()
        }
    }

}